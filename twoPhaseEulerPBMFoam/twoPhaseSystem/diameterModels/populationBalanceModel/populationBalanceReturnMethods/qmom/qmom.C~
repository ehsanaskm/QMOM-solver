/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | foam-extend: Open Source CFD
   \\    /   O peration     |
    \\  /    A nd           | For copyright notice see file Copyright
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of foam-extend.

    foam-extend is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.

    foam-extend is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.

Class
    qmom

sourceFiles
    qmom.H

Author
    Ehsan Askari, M.Sc
    ehsan.askari@usherbrooke.ca

\*---------------------------------------------------------------------------*/

#include "qmom.H"
#include "addToRunTimeSelectionTable.H"
#include "zeroGradientFvPatchFields.H"
#include "populationBalanceModel.H"
#include "bound.H"
#include "fvm.H"
//Added by Ehsan
#include "twoPhaseSystem.H"
#include "scalar.H"
#include "simpleMatrix.H"

// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

namespace Foam
{
    defineTypeNameAndDebug(qmom, 0);
    addToRunTimeSelectionTable(populationBalanceReturn, qmom, dictionary);


// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

// Construct from dictionary
qmom::qmom
(
	const word& name,
	populationBalanceModel& populationBalanceModel
)
:
	populationBalanceReturn(name, populationBalanceModel),
	populationBalanceModel_(populationBalanceModel),
	alpha_(populationBalanceModel.alpha()),

	dict_
    (
        populationBalanceModel_.subDict("qmomCoeffs")
    ),

	dsauter
	(
		IOobject
		(
			"dsauter",
			alpha_.time().timeName(),
			alpha_.db(),
			IOobject::MUST_READ,
			IOobject::AUTO_WRITE
		),
		alpha_.mesh()
	),

	// Sauter diameter d32
	d32_
	(
		IOobject
		(
			"d32",
			alpha_.time().timeName(),
			alpha_.db(),
			IOobject::NO_READ,
			IOobject::NO_WRITE
		),
         	alpha_.mesh(),
		dimensionedScalar("SMALL", dimLength, SMALL)
	),

  /////////////////////////////////////////////////////////////////

  	m0
  	(
  		IOobject
  		(
  			"m0",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),

  	m1
  	(
  		IOobject
  		(
  			"m1",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	m2
  	(
  		IOobject
  		(
  			"m2",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	m3
  	(
  		IOobject
  		(
  			"m3",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	m4
  	(
  		IOobject
  		(
  			"m4",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	m5
  	(
  		IOobject
  		(
  			"m5",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
    w1
  	(
  		IOobject
  		(
  			"w1",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	w2
  	(
  		IOobject
  		(
  			"w2",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	w3
  	(
  		IOobject
  		(
  			"w3",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
       L1
  	(
  		IOobject
  		(
  			"L1",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	L2
  	(
  		IOobject
  		(
  			"L2",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),
  	L3
  	(
  		IOobject
  		(
  			"L3",
  			alpha_.time().timeName(),
  			alpha_.db(),
  			IOobject::MUST_READ,
  			IOobject::AUTO_WRITE
  		),
  		alpha_.mesh()
  	),

	ResidualAlphaForDsauter_(dict_.lookup("ResidualAlphaForDsauter")),
  ResidualAlphaForAdjust_(dict_.lookup("ResidualAlphaForAdjust")),
  ResidualAlphaForCorrect_(dict_.lookup("ResidualAlphaForCorrect")),
  m0_(dict_.lookup("m0")),
  m1_(dict_.lookup("m1")),
  m2_(dict_.lookup("m2")),
  m3_(dict_.lookup("m3")),
  m4_(dict_.lookup("m4")),
  m5_(dict_.lookup("m5")),
  w1_(dict_.lookup("w1")),
  w2_(dict_.lookup("w2")),
  w3_(dict_.lookup("w3")),
  L1_(dict_.lookup("L1")),
  L2_(dict_.lookup("L2")),
  L3_(dict_.lookup("L3")),
	Nm_(readLabel(dict_.lookup("Nm"))),
  nodes_(readLabel(dict_.lookup("nodes"))),
  dm_(dict_.lookup("dm")),
	h0_(dict_.lookup("h0")),
	hf_(dict_.lookup("hf")),
	beta1_(dict_.lookup("beta1")),
	beta2_(dict_.lookup("beta2")),
	betaPB_(dict_.lookup("betaPB")),
	k1_(dict_.lookup("k1")),
	sigma_(dict_.lookup("sigma")),
	breakCoeff_(dict_.lookup("breakCoeff")),
	coalCoeff_(dict_.lookup("coalCoeff")),
	S_(dict_.lookup("S")),
	dMin_(dict_.lookup("dMin")),
	dMax_(dict_.lookup("dMax")),
	maxIters_(readLabel(dict_.lookup("maxIters"))),
	loopTolerance_(readScalar(dict_.lookup("loopTolerance")))



{
	Info << "Selecting method for population balance model" << endl;
}

// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

qmom::~qmom()
{}

// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

scalar qmom::funcTest(scalar& x, scalar& y,	scalar& z) const
{
	 if ( y >= x && y <= z)
    {
      return 1.0;
    }
	 else
    {
      return 0.0;
    }
}

scalar  qmom::kronecker(label& i, label& j) const
{
  if (i == j) return 1.0;

  else return 0.0;
}

void qmom::breakupKernel(PtrList<volScalarField>& S, PtrList<volScalarField>& w, PtrList<volScalarField>& L, const volScalarField& alpha) const
{

	scalar d_i;
  scalar d_j;


   scalar *diam = new scalar[Nm_+ 1];



  //  diam[0] = Foam::pow(4, -1./3.)*dm_.value()*1000;
  //  diam[1] =                  dm_.value()*1000;
  //  diam[2] = Foam::pow(4,  1./3.)*dm_.value()*1000;



      diam[0] = average(L[1]).value();
      diam[1] = average(L[2]).value();
      diam[2] = average(L[3]).value();
Info<<"L1= "<<average(L[1]).value()<<endl;
Info<<"L2= "<<average(L[2]).value()<<endl;
Info<<"L3= "<<average(L[3]).value()<<endl;

  //  diam[1] = 0.00718;
  //  diam[2] = 0.00252;

    volScalarField vf = 1.-alpha;
    //volScalarField vf = alpha;

for(int k = 0; k <= Nm_-1; k++)
{
	for (int i = 0; i<= nodes_-1; i++)
	{


  			d_i = diam[i]/1000;


  			for(int j = i+1 ; j <= nodes_-1 ; j++)
   			{

  				d_j = diam[j]/1000;


                  S[k]  +=   populationBalanceModel_.rhoa().value()
        									* populationBalanceModel_.breakupModel().breakupRate(vf, d_j, d_i)*w[i+1]
                         * Foam::pow(2.0,   scalar((3.0-k)/3.0))/Foam::pow(diam[i], k);



  			}

	}


}

for(int k = 0; k <= Nm_-1; k++)
{

  for (int i = 0; i<= nodes_-1; i++)
	{


  			d_i = diam[i];


  			for(int j = i+1 ; j <= nodes_-1 ; j++)
   			{

  				d_j = diam[j];


                //  S[k]  -=   populationBalanceModel_.rhoa().value()
        	//								* populationBalanceModel_.breakupModel().breakupRate(vf, d_j, d_i)*w[i+1];
                  S[k]  -=   populationBalanceModel_.rhoa().value()
        									*w[i+1];


  			}

	}

}


	return;
}

void qmom::coalescenceKernel
(
	PtrList<volScalarField>& S,
	PtrList<volScalarField>& w,
  PtrList<volScalarField>& L,
	const volScalarField& alpha,
	const volScalarField& epsilon
)
const
{

  scalar d_i;
  scalar d_j;



     scalar *diam = new scalar[Nm_+ 1];

     diam[0] = average(L[1]).value();
     diam[1] = average(L[2]).value();
     diam[2] = average(L[3]).value();

//    diam[0] = Foam::pow(4, -1./3.)*dm_.value()*1000;
//    diam[1] =                  dm_.value()*1000;
//    diam[2] = Foam::pow(4,  1./3.)*dm_.value()*1000;
//    diam[0] = 15.28;
//    diam[1] = 7.18;
  //  diam[2] = 2.52;
    volScalarField epsf = epsilon;


for(int k = 0; k <= Nm_-1; k++)
{
	for (int i = 0; i<=nodes_-1; i++)
	{
			d_i = diam[i]/1000;


			for(int  j = 0 ; j <= nodes_-1 ; j++)
			{
				d_j = diam[j]/1000;


				S[k] += 0.5*populationBalanceModel_.rhoa().value()
				                      * populationBalanceModel_.coalescenceModel().coalescenceRate(d_i,d_j,epsf)*w[j]
                              *Foam::pow ((Foam::pow(d_i, 3.0)+Foam::pow(d_j, 3.0)), scalar(k/3.0));


			}


	}
}

for(int k = 0; k <= Nm_-1; k++)
{
	for (int i = 0; i<=nodes_-1; i++)
	{
			d_i = diam[i];


			for(int  j = 0 ; j <= nodes_-1 ; j++)
			{
				d_j = diam[j];


				S[k] -= populationBalanceModel_.rhoa().value()*Foam::pow(diam[i], k)*w[i]
				                      * populationBalanceModel_.coalescenceModel().coalescenceRate(d_i,d_j,epsf)*w[j];



			}


	}
}


	return;
}


void qmom::weightsAbscissas(PtrList<volScalarField>& w, PtrList<volScalarField>& L, PtrList<volScalarField>& m, const volScalarField alpha) const
{
  label N=lrint(nodes_);
  scalar matriceP[N*N][N*N],ai[N*N],bi[N*N];
  scalar d[N*N],a[N*N][N*N],v[N*N][N*N],alphaii[N*N];

  forAll(alpha, II)
  {
	//- construct the Jacobi matrix P[][] calculation
	for(label i=1; i<=2*N+1; i++)
    {
      if(i==1) {matriceP[i][1]=1.0;}
      else     {matriceP[i][1]=0.0;}
    }
    m[0][II] = 1.0 ;  // forced to be unit

    // second column
    for(label i=1; i<=2*N; i++)
    {
         matriceP[i][2] = pow(-1,i-1)*mag(m[i-1][II]);
    }

    //rest of the column
    for(label j=3; j<= 2*N+1; j++)
    {
       for(label i=1; i<= 2*N+2-j; i++)
       {
			matriceP[i][j] = matriceP[1][j-1]*matriceP[i+1][j-2]
                           - matriceP[1][j-2]*matriceP[i+1][j-1];
       }
    }

    // calculation of alpha[i]
    alphaii[1]=0.0;
    for(label i=2; i<= 2*N; i++)
    {
       	alphaii[i] = matriceP[1][i+1]/(matriceP[1][i]*matriceP[1][i-1]);
    }

    //- calculation of coefficients a[i] and b[i]
    for(label i=1; i<=N; i++)
    {
		ai[i] = alphaii[2*i] + alphaii[2*i-1];
    }

    for(label i=1; i<= N-1; i++)
    {
		bi[i] = ::sqrt(mag(alphaii[2*i+1]*alphaii[2*i])); // positive root
    }

	//- eigenValues and eigenVector for the Jacobi matrice
	// Diagonal of symmetric tridiagonal matrice
	for (int i=1;i<=N;i++)
	{
      a[i][i]   = ai[i];
	}

	// Subdiagonal of symmetric tridiagonal matrix
	for (int i=1;i<N;i++)
	{
      a[i+1][i] = a[i][i+1] = bi[i];
	}
      a[3][1]=a[1][3]=0.;

	// tensor definition
	tensor ABC;
	tensor evs;

	// filling the tensor ABC
	// WARNING ! max N=3 (nodes of quadrature)
	ABC.xx()=a[1][1]; ABC.xy()=a[1][2]; ABC.xz()=a[1][3];
	ABC.yx()=a[2][1]; ABC.yy()=a[2][2]; ABC.yz()=a[2][3];
	ABC.zx()=a[3][1]; ABC.zy()=a[3][2]; ABC.zz()=a[3][3];

	// calculating eigenvalues
	vector e_values=eigenValues(ABC);

	// calculating eigenvector
	evs = eigenVectors(ABC);

	// allocation of the eigenvector
	v[1][1] = evs.xx();
	v[1][2] = evs.yx();
	v[1][3] = evs.zx();

	// allocation of the eigenvalues
	d[1] = e_values.x();
	d[2] = e_values.y();
	d[3] = e_values.z();

	//- final allocation
	for(int i=1; i<=N; i++)
	{
      // weights are the first component of eigenVectors
      w[i][II] = mag(m[0][II]*sqr(v[1][i]));
      if(w[i][II] <= 0 || w[i][II] > 1) w[i][II]=alpha[II];

      // abscissas are the eigenValues

      L[i][II] = mag(d[i]);


	} // end loop i
  } // end loop forALL

  return;
}

tmp<volScalarField> qmom::SauterDiameter(PtrList<volScalarField>& m, const volScalarField& alpha) const
{
  const fvMesh& mesh = alpha_.mesh();


  volScalarField result
  (
			IOobject
			(
				"result",
				mesh.time().timeName(),
				mesh,
				IOobject::NO_READ,
				IOobject::NO_WRITE
			),
			  alpha
                         // dsauter

  );



  // partial result of Sauter diameter d32
    result = m[3]/(m[2]+SMALL)/1000.0;

  forAll(result, cellI)
  {
	  if(alpha[cellI] > ResidualAlphaForDsauter_.value())
	  {
			//if (result[cellI] > 1.e-6 )
			//{
				result[cellI] = max(dMin_.value(), min(result[cellI], dMax_.value()));
			//}
	  }
	  else
	  {
			   result[cellI] = dMin_.value();
	  }
  }



  return tmp<volScalarField>
  (
		new volScalarField
		(
			IOobject
			(
				"d32",
				mesh.time().timeName(),
				mesh,
				IOobject::NO_READ,
				IOobject::AUTO_WRITE
			),
			result//*
		//	dimensionedScalar
		//	(
			//   "one",
			//   dimLength,
		//	   1.
		//	)
		)
  );



}



void qmom::adjust(PtrList<volScalarField>& S, PtrList<volScalarField>& L,const volScalarField& alpha) const
{

	for(int j=0; j<=Nm_-1; j++)
   {
      forAll(S[j], II)
		{
			S[j][II]=0;
		}
   }

   //limitation to 10 mm of diameter
   for(int i=0; i<=nodes_; i++)
    {
             forAll(L[i], II)
           {
                if(L[i][II] > 10)
                {
                L[i][II] = 10;
                }
           }
    }

/*
	for(int i=1; i<=nodes_; i++)
   {
      forAll(L[i], I)
		{
///////////////////////////////////////////////////////////////
/           if(alpha[I] > ResidualAlphaForDsauter_.value())
            {


                L[i][I] = max(dMin_.value(), min(L[i][I], dMax_.value()));

            }
            else
            {
                 L[i][I] = dMin_.value();
            }

///////////////////////////////////////////////////////////////

		 }
   }
*/

}


// *******************************************************************************************************************************

// calculacte and correct variables
void qmom::correct()
{
  const fvMesh& mesh = alpha_.mesh();

 PtrList<volScalarField> source(Nm_);
 PtrList<volScalarField> m(2*Nm_);
 PtrList<volScalarField> w(2*nodes_);
 PtrList<volScalarField> L(2*nodes_);


  volScalarField source_ini =
    mesh.objectRegistry::lookupObject<volScalarField>("source_ini");

  volScalarField m_ini =
    mesh.objectRegistry::lookupObject<volScalarField>("m_ini");

  volScalarField w_ini =
    mesh.objectRegistry::lookupObject<volScalarField>("w_ini");

  volScalarField L_ini =
    mesh.objectRegistry::lookupObject<volScalarField>("L_ini");



  for(label j=0;j<=Nm_-1;j++)
	 {
		 word sourceName = "Sb_" + Foam::name(j);
		 word fName = "m_" + Foam::name(j);


		 source.set
		 ( j,
	      volScalarField
	      (
	         IOobject
	         (
				    sourceName,
					 mesh.time().timeName(),
					 mesh,
					 IOobject::NO_READ,
				         IOobject::AUTO_WRITE
			   ),
	         source_ini
	      )
	    );

		 m.set
		 ( j,
	      volScalarField
	      (
	         IOobject
	         (
				    fName,
					 mesh.time().timeName(),
					 mesh,
					 IOobject::NO_READ,
				         IOobject::AUTO_WRITE
			   ),
                m_ini
	      )
	    );

	 }

   for(label j=0;j<=nodes_;j++)
 	 {
 		 word wName = "w_" + Foam::name(j);
 		 word LName = "L_" + Foam::name(j);


 		 w.set
 		 ( j,
 	      volScalarField
 	      (
 	         IOobject
 	         (
 				    wName,
 					 mesh.time().timeName(),
 					 mesh,
 					 IOobject::NO_READ,
 				  IOobject::AUTO_WRITE
 			   ),
 	         w_ini
 	      )
 	    );

 		 L.set
 		 ( j,
 	      volScalarField
 	      (
 	         IOobject
 	         (
 				    LName,
 					 mesh.time().timeName(),
 					 mesh,
 					 IOobject::NO_READ,
 				   IOobject::AUTO_WRITE
 			   ),
                 L_ini
 	      )
 	    );

 	 }
   m.set
   ( 0,
    volScalarField
    (
       IOobject
       (
        "m0",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m0
    )
   );
   m.set
   ( 0,
    volScalarField
    (
       IOobject
       (
        "m0",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m0
    )
   );
   m.set
   ( 1,
    volScalarField
    (
       IOobject
       (
        "m1",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m1
    )
   );
   m.set
   ( 2,
    volScalarField
    (
       IOobject
       (
        "m2",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m2
    )
   );
   m.set
   ( 3,
    volScalarField
    (
       IOobject
       (
        "m3",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m3
    )
   );
   m.set
   ( 4,
    volScalarField
    (
       IOobject
       (
        "m4",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m4
    )
   );
   m.set
   ( 5,
    volScalarField
    (
       IOobject
       (
        "m5",

                   alpha_.time().timeName(),
                   alpha_.db(),
       IOobject::NO_READ,
             IOobject::NO_WRITE
     ),
            m5
    )
   );

L.set
( 1,
 volScalarField
 (
    IOobject
    (
     "L1",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         L1
 )
);
L.set
( 2,
 volScalarField
 (
    IOobject
    (
     "L2",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         L2
 )
);
L.set
( 3,
 volScalarField
 (
    IOobject
    (
     "L3",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         L3
 )
);
w.set
( 1,
 volScalarField
 (
    IOobject
    (
     "w1",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         w1
 )
);
w.set
( 2,
 volScalarField
 (
    IOobject
    (
     "w2",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         w2
 )
);
w.set
( 3,
 volScalarField
 (
    IOobject
    (
     "w3",

                alpha_.time().timeName(),
                alpha_.db(),
    IOobject::NO_READ,
          IOobject::NO_WRITE
  ),
         w3
 )
);

//m[0]=m0;m[1]=m1;m[2]=m2;m[3]=m3;m[4]=m4;m[5]=m5;
m[0]=m0_.value();m[1]=m1_.value();m[2]=m2_.value();m[3]=m3_.value();m[4]=m4_.value();m[5]=m5_.value();
w[1]=w1;w[2]=w2;w[3]=w3;
L[1]=L1;L[2]=L2;L[3]=L3;
//w[1]=w1_.value();w[2]=w2_.value();w[3]=w3_.value();
//L[1]=L1_.value();L[2]=L2_.value();L[3]=L3_.value();


//////////////////////////////////////////////////////////////////////////////////////////////////////////


  volScalarField alpha =
    mesh.objectRegistry::lookupObject<volScalarField>("alpha.air");

  volScalarField epsilon =
   mesh.objectRegistry::lookupObject<volScalarField>("epsilon.water");


  surfaceScalarField phia =
    mesh.objectRegistry::lookupObject<surfaceScalarField>("phi.air");



		qmom::adjust(source,L,alpha);

  /*  Info << "L1" << average(L[1]) << endl;
    Info << "L2" << average(L[2]) << endl;
    Info << "L3" << average(L[3]) << endl;
    Info << "w1" << average(w[1]) << endl;
    Info << "w2" << average(w[2]) << endl;
    Info << "w3" << average(w[3]) << endl;*/


 		for(label i=0;i<=Nm_-1;i++)
		{
			// update bubbles breakage/coalescence

	  	 	qmom::coalescenceKernel(source,w,L,alpha,epsilon);


	  		qmom::breakupKernel(source,w,L,alpha);


	  	volScalarField Sb = source[i]/
		                            populationBalanceModel_.breakupModel().rhoa();



	//		if(i != (Nm_-1)/2)

		//	{


     word fScheme("div(phia,mi)"); //Vase inke pointerlist darim vase m[i] az een estafe kardim


     fvScalarMatrix miEqn
     (

         fvm::ddt(alpha, m[i])
        + fvm::div(fvc::flux(phia, alpha, fScheme), m[i], fScheme)
        - fvm::Sp(fvc::div(phia), m[i])


 /*       fvm::ddt(m[i])
        + fvm::div(phia, m[i], fScheme)
*/

     );

				solve(miEqn == Sb);
  //        miEqn.solve();


	//		}
		}



m[0]=mag(m[0]);
m[1]=mag(m[1]);
m[2]=mag(m[2]);
m[3]=mag(m[3]);
m[4]=mag(m[4]);
m[5]=mag(m[5]);


    qmom::weightsAbscissas(w,L,m,alpha);


    m[0]=mag(m[0]);
    m[1]=mag(m[1]);
    m[2]=mag(m[2]);
    m[3]=mag(m[3]);
    m[4]=mag(m[4]);
    m[5]=mag(m[5]);


		qmom::adjust(source,L,alpha);

    w[1]=mag(w[1])/(mag(w[1])+mag(w[2])+mag(w[3])+SMALL);
    w[2]=mag(w[2])/(mag(w[1])+mag(w[2])+mag(w[3])+SMALL);
    w[3]=mag(w[3])/(mag(w[1])+mag(w[2])+mag(w[3])+SMALL);


  //  L[1]=0.012*mag(L[1])/(mag(L[1])+mag(L[2])+mag(L[3])+SMALL);
   // L[2]=0.012*mag(L[2])/(mag(L[1])+mag(L[2])+mag(L[3])+SMALL);
   // L[3]=0.012*mag(L[3])/(mag(L[1])+mag(L[2])+mag(L[3])+SMALL);




	qmom::adjust(source,L,alpha);




	// update Sauter diameter d32, relax and correct BC
        dsauter = SauterDiameter(m,alpha);




	d32_ = SauterDiameter(m,alpha)*dimensionedScalar
			(
			   "one",
			   dimLength,
			   1.
			);

        dsauter.relax();
        dsauter.correctBoundaryConditions();


        d32_.relax();
        d32_.correctBoundaryConditions();

//m0=m[0];m1=m[1];m2=m[2];m3=m[3];m4=m[4];m5=m[5];
w1=w[1];w2=w[2];w3=w[3];
L1=L[1];L2=L[2];L3=L[3];


}

// update final calculation






void qmom::updateSauterDiameter()
{
   // mesh declaration




   Info << nl << " *********************************************************************** "<< endl;
   Info << nl << "           Updating Sauter diameter d32 by using " << populationBalanceReturn::name() << endl;
   Info << nl << "           min/avg/max d32: " << min(dsauter).value()*1000
              << "/" << average(dsauter).value()*1000<< "/" << max(dsauter).value()*1000<< "mm." << endl;
   Info << nl << " *********************************************************************** "<< endl;
	Info << " " << endl;
}


} // end of namespace
// **************************************************************************************************************************** //
